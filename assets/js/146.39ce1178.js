(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{462:function(e,i,a){"use strict";a.r(i);var n=a(4),t=Object(n.a)({},(function(){var e=this,i=e._self._c;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h2",{attrs:{id:"介绍"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),i("ol",[i("li",[i("p",[i("strong",[e._v("Linux 内核")]),e._v(":  Linux 是一个免费、开源的 Unix-like 操作系统内核, 最初由 Linus Torvalds 开发。它负责管理硬件资源、文件系统、进程管理等底层操作系统功能。Linux 内核是操作系统的核心组件, 但它本身不足以构成一个完整的操作系统。")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Linux 发行版(Linux Distribution)")]),e._v(":  为了创建一个完整的操作系统, Linux 内核需要与其他组件(如 GNU 工具、库、Shell、图形界面等)集成在一起。这个整合的过程由不同的 Linux 发行版完成。每个 Linux 发行版都基于 Linux 内核, 并添加了其他必要的软件和工具, 以提供一个功能完备的操作系统。Debian、Ubuntu、Fedora、CentOS、Arch Linux 等都是不同的 Linux 发行版。")])]),e._v(" "),i("li",[i("p",[i("strong",[e._v("Debian 和 Linux 的关系")]),e._v(":  Debian 是一个基于 Linux 内核的操作系统发行版, 它使用 Linux 内核作为其操作系统内核。Debian 通过将 Linux 内核与其他软件包(如 GNU 工具、桌面环境、应用程序等)整合在一起, 提供了一个完整的 Linux 操作系统。")])])]),e._v(" "),i("p",[e._v('所以, Linux 既指代了操作系统内核, 也用来描述基于该内核的操作系统。一般情况下, 当人们说 "Linux" 时, 他们更可能是指整个操作系统, 而不仅仅是内核。然而, 在严格的技术术语中, "Linux" 是指内核, 而 Linux 发行版是指整个操作系统。')]),e._v(" "),i("h2",{attrs:{id:"发行版"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#发行版"}},[e._v("#")]),e._v(" 发行版")]),e._v(" "),i("h3",{attrs:{id:"debian"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#debian"}},[e._v("#")]),e._v(" Debian")]),e._v(" "),i("p",[e._v("Debian 是一种基于 Linux 内核的操作系统发行版。具体来说, 以下是关于 Debian 和 Linux 之间关系的详细信息:")]),e._v(" "),i("p",[e._v("Debian 是操作系统:  Debian 不仅包含了 Linux 内核, 还包括了一个完整的操作系统环境, 包括 GNU 工具(如 Bash shell、Coreutils、GCC 编译器等)以及大量其他软件包。Debian 通过将 Linux 内核与其他软件包和工具集成在一起, 创建了一个功能完备的操作系统。")]),e._v(" "),i("p",[e._v("Debian 使用 Linux 内核:  Debian 采用了 Linux 内核作为其操作系统的内核。Linux 是一个开源的 Unix-like 内核, 由 Linus Torvalds 在 1991 年创建。Debian 选择了 Linux 内核作为其默认内核, 因为它具有广泛的硬件支持和强大的性能。")]),e._v(" "),i("p",[e._v('Debian 的多个版本使用不同的 Linux 内核:  Debian 的不同版本(如稳定版、测试版、不稳定版等)可能会使用不同版本的 Linux 内核, 以适应不同的需求和硬件架构。例如, Debian 11(代号 "Bullseye")使用了特定版本的 Linux 内核, 而下一个版本可能会使用更新的内核版本。')]),e._v(" "),i("p",[e._v("Debian 的定制内核:  尽管 Debian 默认使用标准的 Linux 内核, 但用户和管理员有时可以选择定制内核以满足特定需求。他们可以使用 Debian 提供的工具来编译和安装自己的内核, 或者使用第三方内核。")]),e._v(" "),i("p",[e._v("总的来说, Debian 是一个基于 Linux 内核的操作系统发行版, 它不仅包含了 Linux 内核, 还包括了许多其他关键组件和软件包, 以提供一个完整的、功能丰富的操作系统环境。 Debian 与 Linux 内核之间的协作和集成使其成为广泛使用的 Linux 发行版之一。")]),e._v(" "),i("h2",{attrs:{id:"other"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#other"}},[e._v("#")]),e._v(" other")]),e._v(" "),i("h3",{attrs:{id:"epoll"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[e._v("#")]),e._v(" epoll")]),e._v(" "),i("blockquote",[i("p",[e._v("推荐阅读:  "),i("a",{attrs:{href:"https://www.jianshu.com/p/31cdfd6f5a48",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.jianshu.com/p/31cdfd6f5a48"),i("OutboundLink")],1)])]),e._v(" "),i("p",[e._v("Linux 的 epoll(事件轮询)机制是一种高效的事件通知方法, 用于监视文件描述符上的事件并进行异步事件处理。它通常用于构建高性能的网络服务器, 如 Web 服务器, 代理服务器和聊天服务器等, 以处理大量的并发连接。")]),e._v(" "),i("RText",{attrs:{text:"以下是 epoll 机制的一些重要特点和工作原理:"}}),e._v(" "),i("p",[e._v("1.高效的事件通知: epoll 允许应用程序注册多个文件描述符(如套接字)来监视事件, 而不需要阻塞等待事件发生。这降低了 CPU 的负载, 因为应用程序可以等待多个事件而不需要不断轮询。")]),e._v(" "),i("p",[e._v("2.三种事件模式: epoll 支持三种事件触发模式:")]),e._v(" "),i("ul",[i("li",[e._v("EPOLLIN: 当文件描述符可读时触发事件, 如套接字接收数据。")]),e._v(" "),i("li",[e._v("EPOLLOUT: 当文件描述符可写时触发事件, 如套接字可以发送数据。")]),e._v(" "),i("li",[e._v("EPOLLET: 边缘触发模式, 只有在文件描述符状态发生变化时触发事件。这与水平触发模式(默认模式)不同, 后者在文件描述符处于就绪状态时都会触发事件。")])]),e._v(" "),i("p",[e._v("3.注册和注销事件: 应用程序可以使用 epoll_ctl 函数来注册和注销事件, 以及添加或删除文件描述符。这使得应用程序可以在运行时动态管理事件。")]),e._v(" "),i("p",[e._v("4.快速的事件检测: epoll 使用红黑树和双向链表来维护事件列表, 以快速检测和触发事件。这意味着即使有大量的文件描述符, 也能够高效地检测就绪事件。")]),e._v(" "),i("p",[e._v("5.节省系统资源: 与传统的 select 和 poll 模型相比, epoll 更具效率, 因为它避免了遍历所有文件描述符的开销, 仅关注就绪的文件描述符。")]),e._v(" "),i("p",[e._v("6.大规模并发支持: epoll 能够处理大规模并发连接, 这使得它成为构建高性能网络服务器的理想选择。")]),e._v(" "),i("p",[e._v("7.跨平台: 尽管 epoll 是特定于 Linux 的机制, 但类似的机制在其他操作系统上也存在, 如 FreeBSD 的 kqueue 和 Solaris 的 event ports。")]),e._v(" "),i("h3",{attrs:{id:"epoll-机制借助于文件描述符实现。-为什么要这么设计"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#epoll-机制借助于文件描述符实现。-为什么要这么设计"}},[e._v("#")]),e._v(" epoll 机制借助于文件描述符实现。 为什么要这么设计")]),e._v(" "),i("p",[e._v("使用 epoll 机制, 开发者可以编写高效的、可伸缩的网络应用程序, 能够轻松地处理数千甚至数百万的并发连接, 而不会导致性能下降或系统资源耗尽。这使得 epoll 成为构建现代网络服务器和应用程序的重要工具。")]),e._v(" "),i("p",[e._v("Epoll 机制的设计借助于文件描述符, 主要是因为文件描述符是在操作系统中广泛使用的抽象概念, 代表了打开的文件、套接字、管道、设备和其他 I/O 对象。这个设计选择的背后有几个重要原因:")]),e._v(" "),i("ol",[i("li",[i("p",[e._v("统一的接口: 文件描述符提供了一个统一的接口, 用于处理各种类型的 I/O 操作。无论是网络套接字、文件读写还是其他类型的 I/O, 它们都可以用相同的接口来操作。这简化了编程, 使得开发者能够使用相似的方法来管理和处理不同类型的 I/O。")])]),e._v(" "),i("li",[i("p",[e._v("已有的文件描述符系统: 操作系统已经实现了文件描述符管理和事件通知系统。利用这个已有的机制, 内核可以有效地管理文件描述符, 监视它们上面的事件, 并通知应用程序关于事件的信息。这允许应用程序借助操作系统的支持来实现高效的 I/O 操作。")])]),e._v(" "),i("li",[i("p",[e._v("可扩展性: 文件描述符提供了一个可扩展的方法, 因为开发者可以在应用程序中动态打开和关闭文件描述符。这使得 epoll 能够处理大量的文件描述符, 而不需要静态地限制数量, 从而实现了高度可伸缩性。")])]),e._v(" "),i("li",[i("p",[e._v("广泛的应用: 文件描述符的概念不仅适用于网络套接字, 还适用于文件、管道、设备和其他 I/O 对象。因此, 使用文件描述符作为基础, 可以支持多种类型的 I/O 操作, 使 epoll 机制更加通用和灵活。")])])]),e._v(" "),i("p",[e._v("总之, 设计 epoll 机制借助于文件描述符的主要原因是提供了一种通用、可扩展且高效的事件通知机制, 同时与操作系统的已有文件描述符系统相集成, 使得处理 I/O 事件变得更为简单和高效。这种设计有助于构建高性能、可伸缩的网络应用程序, 并广泛用于现代操作系统中。")]),e._v(" "),i("h3",{attrs:{id:"etc-hosts"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#etc-hosts"}},[e._v("#")]),e._v(" "),i("code",[e._v("/etc/hosts/")])]),e._v(" "),i("blockquote",[i("p",[i("code",[e._v("/etc/hosts")]),e._v(" 文件是一个用于静态主机名解析的文件，它在 Unix 和类 Unix 操作系统(如 Linux 和 macOS)中都存在。这个文件可以将主机名映射到 IP 地址，不需要通过 DNS(域名系统)进行查询。它对于小型网络管理或特定主机名到 IP 地址的映射非常有用。")])]),e._v(" "),i("RText",{attrs:{text:"文件的格式"}}),e._v(", 文件的每一行定义一个 IP 地址和一个或多个主机名，格式如下:\n"),i("div",{staticClass:"language-plaintext line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-plaintext"}},[i("code",[e._v("IP_address canonical_hostname [aliases...]\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br")])]),i("ul",[i("li",[i("code",[e._v("IP_address")]),e._v(": 目标主机的 IP 地址。")]),e._v(" "),i("li",[i("code",[e._v("canonical_hostname")]),e._v(": 目标主机的正式名称(规范名称)。")]),e._v(" "),i("li",[i("code",[e._v("aliases")]),e._v("(可选): 目标主机的别名，可以有多个，使用空格分隔。")])])],1)}),[],!1,null,null,null);i.default=t.exports}}]);