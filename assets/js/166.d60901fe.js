(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{482:function(t,v,a){"use strict";a.r(v);var _=a(4),e=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"runtime-getmemory-与-activitymanager-memoryinfo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#runtime-getmemory-与-activitymanager-memoryinfo"}},[t._v("#")]),t._v(" Runtime getMemory 与 ActivityManager.MemoryInfo")]),t._v(" "),v("p",[t._v("在 Android 中, 你可以使用不同的 API 来获取设备的内存信息, 其中包括 Runtime 类的 getRuntime()方法和 ActivityManager.MemoryInfo 类。它们各自用于不同的内存信息获取目的, 以下是它们之间的区别:")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("Runtime.getFreeMemory()")]),t._v("、"),v("code",[t._v("Runtime.totalMemory()")]),t._v(" 和 "),v("code",[t._v("Runtime.maxMemory()")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("Runtime 是 Java 标准库的一部分, 而不是 Android 特定的 API。它提供了一种在 Java 虚拟机中获取内存信息的方式")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Runtime.getRuntime().freeMemory()")]),t._v(" 返回当前可用的内存大小, 它表示 Java 虚拟机中当前空闲的内存")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Runtime.getRuntime().totalMemory()")]),t._v(" 返回 Java 虚拟机当前已分配的总内存大小")])]),t._v(" "),v("li",[v("p",[v("code",[t._v("Runtime.getRuntime().maxMemory()")]),t._v(" 返回 Java 虚拟机试图使用的最大内存大小")])])]),t._v(" "),v("p",[t._v("这些方法主要用于监测应用在 Java 虚拟机中的内存使用情况, 而不是整个设备的内存信息。在 Android 中, 通常更推荐使用 Android 特定的内存管理 API 来获取设备内存信息")]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[v("code",[t._v("ActivityManager.MemoryInfo")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("ActivityManager.MemoryInfo 是 Android 的 API, 它提供了关于设备内存的详细信息")]),t._v(" "),v("li",[t._v("通过创建 ActivityManager.MemoryInfo 的实例, 并使用 ActivityManager 的 getMemoryInfo()方法, 你可以获取包括总内存、可用内存、低内存阈值等在内的更多内存信息")]),t._v(" "),v("li",[t._v("这些信息有助于你监测设备上的内存使用情况, 以便更好地管理应用程序的资源, 并在必要时采取措施来释放内存")])]),t._v(" "),v("p",[t._v("总的来说, Runtime 类的方法主要用于监测 Java 虚拟机内存, 而 "),v("code",[t._v("ActivityManager.MemoryInfo")]),t._v(" 用于监测设备上的系统内存。如果你关心应用程序在设备上的内存使用情况, 通常更建议使用 ActivityManager.MemoryInfo 来获取内存信息, 因为它提供了更多关于设备内存状态的详细信息, 有助于更好地优化你的应用程序")]),t._v(" "),v("h2",{attrs:{id:"meminfo"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#meminfo"}},[t._v("#")]),t._v(" meminfo")]),t._v(" "),v("p",[t._v("在 Android 中，可以使用 "),v("code",[t._v("adb shell dumpsys meminfo")]),t._v(" 命令来查看应用的内存使用情况。这些信息包括多个指标，如 "),v("code",[t._v("PSS(Proportional Set Size")]),t._v(")、私有脏页面、私有干净页面、交换 PSS(SwapPSS)等。让我们解析一下这些指标，并解释它们在内存分析中的意义")]),t._v(" "),v("h3",{attrs:{id:"各个字段的含义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#各个字段的含义"}},[t._v("#")]),t._v(" 各个字段的含义")]),t._v(" "),v("ol",[v("li",[t._v("Pss Total:")])]),t._v(" "),v("ul",[v("li",[t._v("PSS(Proportional Set Size): 反映进程使用的物理内存大小。这是内存的真实使用情况，按比例分配共享内存的部分。比如，如果有两个进程共享 1MB 的内存，每个进程的 PSS 会增加 512KB")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("Private Dirty:")])]),t._v(" "),v("ul",[v("li",[t._v("私有脏页面: 进程独占且已被修改的内存页面。这些页面不能被交换到磁盘(对交换内存的情况来说)，并且不能被其他进程共享")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("Private Clean:")])]),t._v(" "),v("ul",[v("li",[t._v("私有干净页面: 进程独占但未被修改的内存页面。这些页面可以被交换到磁盘以释放内存，或者当它们不再需要时，可以简单地丢弃并从原始资源重新读取")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("SwapPss:")])]),t._v(" "),v("blockquote",[v("p",[t._v("理解 SwapPss 的概念涉及对内存管理和交换(swap)机制的理解。在操作系统中，内存(RAM)是有限的资源，而交换空间(swap space)是一种辅助内存管理的机制，当物理内存不足时，系统会将一部分内存页面写到磁盘的交换空间中，从而释放物理内存。")])]),t._v(" "),v("ul",[v("li",[t._v("交换 PSS: 表示已经被交换到磁盘的内存量。类似于 PSS，但它特指已经被写到交换空间(swap)的内存")])]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("Heap Size:")])]),t._v(" "),v("ul",[v("li",[t._v("堆大小: 进程当前分配的堆内存总大小")])]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("Heap Alloc:")])]),t._v(" "),v("ul",[v("li",[t._v("堆分配: 已经被进程使用的堆内存量")])]),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[t._v("Heap Free:")])]),t._v(" "),v("ul",[v("li",[t._v("堆空闲: 堆内存中未被使用的部分")])]),t._v(" "),v("h3",{attrs:{id:"内存区域解释"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存区域解释"}},[t._v("#")]),t._v(" 内存区域解释")]),t._v(" "),v("ol",[v("li",[t._v("Native Heap:")])]),t._v(" "),v("ul",[v("li",[t._v("原生堆，指的是使用 C/C++ 分配的内存。这部分内存通常由应用的本地代码(如通过 JNI 调用的本地库)分配和管理")])]),t._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[t._v("Dalvik Heap:")])]),t._v(" "),v("ul",[v("li",[t._v("Dalvik 堆，指的是应用的 Java 堆内存。这部分内存用于存储 Java 对象，在 ART(Android Runtime)中实际运行")])]),t._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[t._v("Stack:")])]),t._v(" "),v("ul",[v("li",[t._v("栈内存，每个线程有自己的栈，用于存储线程的局部变量、方法调用信息等")])]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("Ashmem:")])]),t._v(" "),v("ul",[v("li",[t._v("Android 共享内存("),v("code",[t._v("Anonymous Shared Memory")]),t._v(")，用于进程间通信(IPC)的一种共享内存机制")])]),t._v(" "),v("ol",{attrs:{start:"5"}},[v("li",[t._v("Gfx dev:")])]),t._v(" "),v("ul",[v("li",[t._v("图形设备内存，指的是 GPU 使用的内存，用于存储图形缓冲区等")])]),t._v(" "),v("ol",{attrs:{start:"6"}},[v("li",[t._v("Other dev:")])]),t._v(" "),v("ul",[v("li",[t._v("其他设备内存，指的是系统中其他设备使用的内存")])]),t._v(" "),v("ol",{attrs:{start:"7"}},[v("li",[v("code",[t._v(".so mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的共享对象(Shared Object)，指的是通过内存映射(mmap)加载的本地库(.so 文件)")])]),t._v(" "),v("ol",{attrs:{start:"8"}},[v("li",[v("code",[t._v(".apk mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的 APK 文件，指的是通过内存映射加载的 APK 文件内容")])]),t._v(" "),v("ol",{attrs:{start:"9"}},[v("li",[v("code",[t._v(".ttf mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的字体文件(TrueType Font)，指的是通过内存映射加载的字体文件")])]),t._v(" "),v("ol",{attrs:{start:"10"}},[v("li",[v("code",[t._v(".dex mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的 DEX 文件，指的是通过内存映射加载的 Dalvik 字节码文件(.dex 文件)")])]),t._v(" "),v("ol",{attrs:{start:"11"}},[v("li",[v("code",[t._v(".oat mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的 OAT 文件，指的是通过内存映射加载的编译后的 ART 字节码文件(.oat 文件)")])]),t._v(" "),v("ol",{attrs:{start:"12"}},[v("li",[v("code",[t._v(".art mmap")]),t._v(":")])]),t._v(" "),v("ul",[v("li",[t._v("映射的 ART 文件，指的是通过内存映射加载的 ART 运行时使用的文件")])]),t._v(" "),v("ol",{attrs:{start:"13"}},[v("li",[t._v("Other mmap:")])]),t._v(" "),v("ul",[v("li",[t._v("其他内存映射，指的是通过内存映射加载的其他文件")])]),t._v(" "),v("ol",{attrs:{start:"14"}},[v("li",[t._v("EGL mtrack:")])]),t._v(" "),v("ul",[v("li",[t._v("EGL 内存跟踪，指的是与 EGL(嵌入式图形库)相关的内存")])]),t._v(" "),v("ol",{attrs:{start:"15"}},[v("li",[t._v("GL mtrack:")])]),t._v(" "),v("ul",[v("li",[t._v("OpenGL 内存跟踪，指的是与 OpenGL 相关的内存")])]),t._v(" "),v("ol",{attrs:{start:"16"}},[v("li",[t._v("Unknown:")])]),t._v(" "),v("ul",[v("li",[t._v("未知内存，指的是无法分类的内存")])]),t._v(" "),v("ol",{attrs:{start:"17"}},[v("li",[t._v("TOTAL:")])]),t._v(" "),v("ul",[v("li",[t._v("总内存，指的是上述所有内存区域的总和")])])])}),[],!1,null,null,null);v.default=e.exports}}]);