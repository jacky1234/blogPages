(window.webpackJsonp=window.webpackJsonp||[]).push([[201],{517:function(t,v,i){"use strict";i.r(v);var a=i(4),_=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#库"}},[t._v("#")]),t._v(" 库")]),t._v(" "),v("h3",{attrs:{id:"snapkit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#snapkit"}},[t._v("#")]),t._v(" snapkit")]),t._v(" "),v("p",[t._v("SnapKit 是一个用于 iOS 和 macOS 开发的 Swift 库, 用于简化 Auto Layout 约束的创建和管理。Auto Layout 是一种界面布局技术, 用于在不同尺寸和设备方向上自动调整界面元素的位置和大小, 以便适应各种屏幕。SnapKit 使 Auto Layout 更容易使用, 通过编程方式定义约束, 而不是使用 Interface Builder。")]),t._v(" "),v("p",[t._v("以下是 SnapKit 的一些主要特点和用法:")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("简化的语法: SnapKit 提供了一种直观且易于阅读的 DSL(领域特定语言), 用于编写 Auto Layout 约束。它的语法类似于自然语言, 减少了使用 Auto Layout 时的冗余代码。")])]),t._v(" "),v("li",[v("p",[t._v("链式调用: SnapKit 允许您通过链式调用方法来定义约束。您可以依次指定每个约束的属性, 使代码更具可读性。")])]),t._v(" "),v("li",[v("p",[t._v("类型安全: SnapKit 是用 Swift 编写的, 因此它可以充分利用 Swift 的类型安全性。这意味着如果您尝试创建不合法的约束, 将在编译时发现错误。")])]),t._v(" "),v("li",[v("p",[t._v("支持相对约束: SnapKit 支持相对约束, 允许您定义一个视图相对于另一个视图的位置和大小。这对于创建响应式布局非常有用。")])]),t._v(" "),v("li",[v("p",[t._v("多平台支持: SnapKit 可以用于 iOS 和 macOS 应用程序的界面布局。")])]),t._v(" "),v("li",[v("p",[t._v("自动布局优化: SnapKit 会自动执行优化以确保您的约束是最有效的, 从而提高应用程序的性能。")])])]),t._v(" "),v("p",[t._v("SnapKit 是一个流行的界面布局库, 特别适用于需要在代码中进行界面布局或希望更好地理解 Auto Layout 的开发人员。它的易用性和强大的功能使得创建复杂的界面布局变得更加简单和高效。")]),t._v(" "),v("h3",{attrs:{id:"uikit"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#uikit"}},[t._v("#")]),t._v(" uikit")]),t._v(" "),v("p",[t._v("UIKit(User Interface Kit)是一个用于构建 iOS 和 tvOS 应用程序的框架, 它是 Apple 的开发工具包之一。UIKit 提供了许多可用于构建用户界面和管理应用程序生命周期的类和工具。")]),t._v(" "),v("p",[t._v("以下是一些 UIKit 的主要特性和组件:")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("视图(Views)")]),t._v(": UIKit 提供了丰富的视图组件, 如 UILabel、UIButton、UITextField、UIImageView 等, 用于构建用户界面元素。这些视图可以组合在一起来创建复杂的用户界面。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("视图控制器(View Controllers)")]),t._v(": UIKit 引入了视图控制器的概念, 用于管理视图的展示和交互。UIViewController 是常见的视图控制器类, 用于管理单个或多个视图的展示、布局和生命周期。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("用户界面布局")]),t._v(": UIKit 提供 Auto Layout 系统, 用于创建自适应的用户界面布局, 确保用户界面在不同设备和方向上都能正确呈现。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("多点触控(Multi-Touch)")]),t._v(": UIKit 支持多点触控, 允许应用程序响应多个手指的操作, 例如捏合、滑动和旋转手势。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("动画和过渡效果")]),t._v(": UIKit 提供了内置的动画和过渡支持, 允许应用程序创建流畅的用户界面效果。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("事件处理")]),t._v(": UIKit 管理用户输入和事件处理, 包括触摸事件、键盘事件、手势事件等。开发人员可以使用委托、目标-动作机制或手势识别器来处理这些事件。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("文本和字体处理")]),t._v(": UIKit 支持文本渲染、字体管理、文本输入和编辑等文本相关的功能。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("图形绘制")]),t._v(": UIKit 提供了 Core Graphics 框架的接口, 允许应用程序进行图形绘制和自定义绘图。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("表视图和集合视图")]),t._v(": UIKit 包括 UITableView 和 UICollectionView, 这两个组件用于展示大量数据, 如列表和网格。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("导航和视图切换")]),t._v(": UIKit 提供了导航控制器(UINavigationController)和标签栏控制器(UITabBarController)等, 用于管理应用程序的导航和多个视图之间的切换。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("设备和屏幕适配")]),t._v(": UIKit 支持不同设备和屏幕尺寸的适配, 以确保应用程序在各种设备上都能正确显示。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("主题和外观")]),t._v(": UIKit 支持应用程序外观和主题的自定义, 使开发人员能够创建独特的用户界面。")])])]),t._v(" "),v("p",[t._v("UIKit 是构建 iOS 和 tvOS 应用程序的基础, 提供了广泛的工具和功能, 使开发人员能够创建各种类型的应用程序, 从简单的工具应用到复杂的娱乐应用和生产力工具。")]),t._v(" "),v("h2",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),v("h3",{attrs:{id:"deriveddata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#deriveddata"}},[t._v("#")]),t._v(" DerivedData")]),t._v(" "),v("p",[v("code",[t._v("~/Library/Developer/Xcode/DerivedData")]),t._v(" 目录是 Xcode 生成项目派生数据的地方。这些派生数据包括编译生成的文件、构建产物、日志、索引文件等, 用于支持项目的编译和开发过程。")]),t._v(" "),v("p",[t._v("通常, 你不需要手动管理 DerivedData 目录中的文件, 因为 Xcode 会自动进行管理。然而, 有时你可能会遇到问题, 例如构建错误或导入项目时的问题, 需要清理或删除 DerivedData 目录中的数据, 以解决这些问题。")]),t._v(" "),v("p",[t._v("在 DerivedData 目录下, 每个项目都有自己的子目录, 子目录的名称通常是项目的 UUID(Universally Unique Identifier)。这些子目录包含有关项目构建和派生数据的信息。")]),t._v(" "),v("p",[t._v("如果你需要手动删除或清理 DerivedData 目录中的数据, 可以按照以下步骤操作:")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("关闭 Xcode。")])]),t._v(" "),v("li",[v("p",[t._v("打开终端应用程序。")])]),t._v(" "),v("li",[v("p",[t._v("使用以下命令删除整个 DerivedData 目录:")])])]),t._v(" "),v("div",{staticClass:"language-shell line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[v("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-rf")]),t._v(" ~/Library/Developer/Xcode/DerivedData\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[t._v("这将删除整个目录及其内容。")]),t._v(" "),v("ol",{attrs:{start:"4"}},[v("li",[t._v("重新启动 Xcode。")])]),t._v(" "),v("p",[t._v("注意: 清理 "),v("code",[t._v("DerivedData")]),t._v(" 目录会删除构建和派生数据, 但不会影响你的项目源代码。项目源代码通常存储在项目文件夹中, 不会受到清理操作的影响。")]),t._v(" "),v("p",[t._v("清理 DerivedData 目录有助于解决一些与构建或派生数据相关的问题, 例如构建错误、索引问题或导入问题。在执行清理操作后, Xcode 将重新生成所需的数据。如果你遇到了特定的问题, 清理 DerivedData 目录可能会是解决问题的一部分。")]),t._v(" "),v("h3",{attrs:{id:"dyld2-与-dyld3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dyld2-与-dyld3"}},[t._v("#")]),t._v(" dyld2 与 dyld3")]),t._v(" "),v("p",[t._v("dyld2 和 dyld3 都是 macOS 和 iOS 系统中的动态链接器(Dynamic Linker), 负责加载和链接应用程序的二进制可执行文件以及相关的共享库(动态链接库)。它们之间的主要区别在于版本和性能优化。")]),t._v(" "),v("p",[t._v("dyld2:")]),t._v(" "),v("ul",[v("li",[t._v("dyld2 是 macOS 和 iOS 早期版本中使用的动态链接器, 它的开发历史相对较长。")]),t._v(" "),v("li",[t._v("dyld2 使用传统的单线程模型, 即一个进程中只有一个线程执行加载和链接操作。")]),t._v(" "),v("li",[t._v("在 dyld2 中, 启动应用程序时加载大量共享库时, 可能会导致较长的启动时间, 特别是在系统上安装了大量共享库的情况下。")]),t._v(" "),v("li",[t._v("dyld2 是纯粹的 in-process, 也就是在程序进程内执行的, 也就意味着只有当应用程序被启动的时候, dyld2 才能开始执行任务。")])]),t._v(" "),v("p",[t._v("dyld3:")]),t._v(" "),v("ul",[v("li",[t._v("dyld3 是苹果公司为了提高动态链接性能而开发的新版本的动态链接器, 最初引入于 macOS High Sierra 和 iOS 11 中。")]),t._v(" "),v("li",[t._v("dyld3 引入了并行加载和链接的概念, 允许多个线程同时加载和链接不同的库, 以提高启动性能。")]),t._v(" "),v("li",[t._v("dyld3 还引入了延迟绑定(Lazy Binding)和新的共享库格式, 以减少启动时的内存占用和加快应用程序的启动速度。")]),t._v(" "),v("li",[t._v("dyld3 则是部分 out-of-process, 部分 in-process。图中, 虚线之上的部分是 out-of-process 的, 在 App 下载安装和版本更新的时候会去执行, out-of-process 会做如下事情:\n"),v("ul",[v("li",[t._v("分析 Mach-o Headers")]),t._v(" "),v("li",[t._v("分析依赖的动态库")]),t._v(" "),v("li",[t._v("查找需要 Rebase & Bind 之类的符号")]),t._v(" "),v("li",[t._v("把上述结果写入缓存")])])])]),t._v(" "),v("p",[t._v("总的来说, dyld3 是为了提高应用程序启动性能而引入的新版本的动态链接器。它引入了并行加载和链接, 延迟绑定等性能优化, 以减少应用程序启动时间并提高整体性能。应用程序的启动时间对于用户体验至关重要, 因此这些改进对于减少启动时间和提高应用程序响应速度非常重要。")]),t._v(" "),v("h3",{attrs:{id:"gcd"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[t._v("#")]),t._v(" GCD")]),t._v(" "),v("p",[t._v("GCD 是 Grand Central Dispatch 的缩写, 是苹果公司为 iOS 和 macOS 开发的多线程和并发编程的技术之一。它提供了一种方便的方式来执行并发任务, 管理多线程和处理异步操作。GCD 旨在简化多线程编程, 提供了高效的多核处理和 CPU 利用率。")]),t._v(" "),v("p",[t._v("GCD 的主要概念包括以下几点:")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("队列(Dispatch Queues)")]),t._v(": GCD 使用队列来管理任务的执行。它有两种主要类型的队列: 串行队列(Serial Queue)和并行队列(Concurrent Queue)。串行队列一次只执行一个任务, 而并行队列可以同时执行多个任务。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("任务(Blocks)")]),t._v(": 任务是以块(Block)的形式定义的, 通常是匿名函数, 包含了要执行的代码。任务可以被提交到队列中, 并由 GCD 负责调度执行。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("调度(Dispatching)")]),t._v(": 将任务提交到队列中, 然后 GCD 负责安排它们的执行。任务可以是同步(阻塞当前线程, 等待任务执行完成)或异步(不阻塞当前线程, 立即返回)。")])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("调度组(Dispatch Groups)")]),t._v(": 允许您将多个任务分组, 以便在它们全部完成后执行其他任务。这对于异步操作的协同工作非常有用。")])])]),t._v(" "),v("p",[t._v("GCD 提供了一种相对容易使用的方式来执行多线程编程, 减少了手动管理线程的复杂性。它有助于开发人员更轻松地利用多核处理器和处理并发任务, 以提高应用的性能和响应性。在 iOS 和 macOS 开发中, GCD 是处理并发编程的首选方式之一。")])])}),[],!1,null,null,null);v.default=_.exports}}]);