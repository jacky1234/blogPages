(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{519:function(t,s,a){"use strict";a.r(s);var e=a(4),n=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("h3",{attrs:{id:"category"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#category"}},[t._v("#")]),t._v(" category")]),t._v(" "),s("p",[t._v("Objective-C 中的分类(Category)是一种强大的特性, 它允许你为现有的类(包括标准类和你自己创建的类)添加新的方法, 而无需创建子类。分类提供了一种在不修改原始类的情况下扩展其功能的方式。你可以在分类中添加实例方法、类方法、甚至属性。"),s("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW2",target:"_blank",rel:"noopener noreferrer"}},[t._v("Categories Add Methods to Existing Classes"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("下面是一个示例, 展示了如何创建一个分类:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MyClass.h")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@interface")]),t._v(" MyClass "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" NSObject\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("originalMethod"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MyClass.m")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@implementation")]),t._v(" MyClass\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("originalMethod "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NSLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"Original method"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("现在, 假设你想要为 MyClass 添加一个新的方法, 但你不想修改 MyClass 的源代码。你可以创建一个分类:")]),t._v(" "),s("div",{staticClass:"language-objc123123ASD line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('\n// MyClass+MyCategory.h\n#import "MyClass.h"\n\n@interface MyClass (MyCategory)\n- (void)newMethod;\n@end\n\n// MyClass+MyCategory.m\n@implementation MyClass (MyCategory)\n- (void)newMethod {\n    NSLog(@"New method");\n}\n@end\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br")])]),s("p",[t._v("现在, MyClass 类有了一个新的方法 newMethod, 而不需要修改 MyClass 类的原始实现。你只需导入 MyClass+MyCategory.h 头文件, 就可以在你的代码中使用 newMethod。")]),t._v(" "),s("p",[t._v("注意, 分类允许你扩展现有类的功能, 但不允许你添加新的实例变量。此外, 如果多个分类为同一个类添加同名的方法, 编译器可能无法确定使用哪个实现, 因此要谨慎处理。一般来说, 建议为分类的方法加上自定义前缀, 以避免冲突。")]),t._v(" "),s("h3",{attrs:{id:"pragma-mark-xxx"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pragma-mark-xxx"}},[t._v("#")]),t._v(" "),s("code",[t._v("#pragma mark - xxx")])]),t._v(" "),s("p",[s("code",[t._v("#pragma")]),t._v(" 开头的代码是一条编译器指令, 是一个特定于程序或编译器的指令。它们不一定适用于其它编译器或其它环境。如果编译器不能识别该指令, 则会将其忽略。它们告诉 Xcode 编译器, 要在编辑器窗格顶部的方法和函数弹出菜单中将代码分隔开")]),t._v(" "),s("h3",{attrs:{id:"符号"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号"}},[t._v("#")]),t._v(" "),s("code",[t._v("+\\-")]),t._v(" 符号")]),t._v(" "),s("p",[s("code",[t._v("-")]),t._v(" 符号用于实例方法, 而 "),s("code",[t._v("+")]),t._v(" 符号用于类方法,类似于 java 中的 static 方法")]),t._v(" "),s("h3",{attrs:{id:"关键字-no-yes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关键字-no-yes"}},[t._v("#")]),t._v(" 关键字 NO/YES")]),t._v(" "),s("p",[t._v("在 Objective-C 中, NO 是一个关键字, 表示逻辑假(false)。它是布尔值 false 的等效表示。与之对应的关键字是 YES, 表示逻辑真(true)。")]),t._v(" "),s("h3",{attrs:{id:"字符串"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),s("blockquote",[s("p",[t._v('@"%p preload model with idx %@ properties %@", self, @(self.context.model.pageIndex), property')])]),t._v(" "),s("p",[t._v("在 Objective-C 字符串中, 使用"),s("code",[t._v('@"..."')]),t._v("表示字符串字面量。在这个字符串字面量中, "),s("code",[t._v("%@")]),t._v(" 是一个格式占位符, 通常用于插入对象的值。")]),t._v(" "),s("p",[t._v("在你的代码片段中, "),s("code",[t._v('@"%p preload model with idx %@ properties %@"')]),t._v(" 是一个包含了格式占位符的字符串。每个占位符都会在字符串中的相应位置插入一个值, 这些值是由占位符后面的变量提供的。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("%p")]),t._v(" 是一个占位符, 表示将一个指针地址插入到字符串中。")]),t._v(" "),s("li",[s("code",[t._v("%@")]),t._v(" 也是一个占位符, 通常用于插入 Objective-C 对象的值。")])]),t._v(" "),s("p",[t._v("具体到你的代码片段, self 表示当前对象的指针, "),s("code",[t._v("@(self.context.model.pageIndex)")]),t._v(" 用于将整数值转换为 Objective-C 对象, property 可能是另一个 Objective-C 对象。所以, "),s("code",[t._v("%@")]),t._v(" 占位符用于将这些值插入到字符串中, 以生成一个包含这些值的日志信息。")]),t._v(" "),s("p",[t._v("例如, 如果 self 指向的对象的地址是 0x12345678, "),s("code",[t._v("self.context.model.pageIndex")]),t._v(' 的值是 5, property 包含字符串"example", 那么这个字符串字面量就会被格式化为:')]),t._v(" "),s("p",[t._v('"0x12345678 preload model with idx 5 properties example"')]),t._v(" "),s("p",[t._v("这样的字符串可以用于日志记录或调试目的。")]),t._v(" "),s("h3",{attrs:{id:"iskindofclass"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#iskindofclass"}},[t._v("#")]),t._v(" isKindOfClass")]),t._v(" "),s("p",[t._v("isKindOfClass 方法是 "),s("code",[t._v("NSObject")]),t._v(" 的一个对象方法, 用于检查对象的类是否与指定类相同或是其子类。如果相同或是子类, 该方法返回 "),s("code",[t._v("YES")]),t._v(", 否则返回 "),s("code",[t._v("NO")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("model isKindOfClass"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("XXX class"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" NO"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[s("code",[t._v("冒号(:)后面的 [XXX class]")]),t._v(" 是一个消息发送的语法, 用于调用对象的方法。")]),t._v(" "),s("p",[t._v("让我解释一下代码的意思:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("[XXX class]")]),t._v(" 表示获取类 XXX 的实例。这是一个类方法, 它返回一个代表 XXX 类的 Class 对象。")]),t._v(" "),s("li",[s("code",[t._v("isKindOfClass:")]),t._v(" 是一个消息(方法)名称, 它接受一个 Class 对象作为参数, 并用于检查调用它的对象是否是该类或其子类的实例。")]),t._v(" "),s("li",[s("code",[t._v("[model isKindOfClass:[XXX class]]")]),t._v(" 这一部分将返回一个布尔值(YES 或 NO), 指示 model 是否是 XXX 类或其子类的实例。")]),t._v(" "),s("li",[s("code",[t._v("== NO")]),t._v(" 用于检查上面的条件是否为假。如果 model 不是 XXX 类或其子类的实例, 条件成立, 然后 return; 语句会导致函数的提前返回。")])]),t._v(" "),s("h3",{attrs:{id:"带有-defaultvalue-的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#带有-defaultvalue-的方法"}},[t._v("#")]),t._v(" 带有 defaultValue 的方法")]),t._v(" "),s("blockquote",[s("p",[t._v("解析:  "),s("code",[t._v("- (NSString *)castStringForKey:(id<NSCopying>)key default:(NSString *)defaultValue;")])])]),t._v(" "),s("ul",[s("li",[s("code",[t._v('方法名 "castStringForKey:default:"')]),t._v(" 明确表明它的作用是从字典中获取指定键对应的字符串值, 并且提供了一个默认值, 以便在必要时返回。这种命名方式能够让开发者清晰地了解方法的功能, 并在需要时使用默认值, 而不会引发异常或错误。")]),t._v(" "),s("li",[t._v("参数: 接受两参数, 一个是 key, 它应该是符合 NSCopying 协议的对象, 通常用作字典的键；另一个是 "),s("code",[t._v("defaultValue")]),t._v(", 它是一个 NSString 类型的默认值, 用于在无法找到指定键对应的值时返回")]),t._v(" "),s("li",[s("strong",[t._v("在 OC 中, 冒号后面的才是参数")])])]),t._v(" "),s("h3",{attrs:{id:"id-引用任何对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#id-引用任何对象"}},[t._v("#")]),t._v(" id 引用任何对象")]),t._v(" "),s("blockquote",[s("p",[t._v("对象的指针为什么要用 id 来表示,  比如 A 类的指针直接使用 A*不就可以了吗")])]),t._v(" "),s("p",[t._v("你的疑问是很合理的。在 Objective-C 中, 确实可以使用类指针来表示对象, 比如 "),s("code",[t._v("A*")]),t._v(" 表示类 A 的对象。实际上, "),s("code",[t._v("A*")]),t._v(" 是一种具体的数据类型, 用于指向 A 类的实例。")]),t._v(" "),s("p",[t._v("而 id 是一种更加通用和灵活的数据类型, 它可以指向任何 Objective-C 对象, 不仅仅是 A 类的对象。这使得 id 更具通用性, 允许在不确定对象类型的情况下引用对象。")]),t._v(" "),s("p",[s("strong",[t._v("为什么要使用 id 呢？")])]),t._v(" "),s("p",[t._v("这主要是因为 Objective-C 是一种动态类型语言, 它允许在运行时动态确定对象的类型。使用 id 可以更容易地实现这种动态性, 因为它不限制你在编译时指定对象的具体类型。这在 Objective-C 的动态特性中是非常有用的, 特别是在处理集合类、代理、反射等情况下。")]),t._v(" "),s("p",[t._v("所以, 虽然可以使用类指针来表示对象, 但 id 更加通用, 可以在更多的情况下使用, 特别是在 Objective-C 动态性和灵活性的背景下。")]),t._v(" "),s("h3",{attrs:{id:"nscopying-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nscopying-协议"}},[t._v("#")]),t._v(" NSCopying 协议")]),t._v(" "),s("p",[t._v("NSCopying 是 Foundation 框架中的一个协议, 通常用于 Objective-C 中的对象复制操作。对象遵循 NSCopying 协议的话, 就需要提供一种复制(或克隆)对象的方式, 以便创建一个新的对象, 该对象与原始对象具有相同的内容。这个协议定义了一个方法:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("copyWithZone"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSZone "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("zone"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这个方法返回一个新对象的副本, 通常由类的实例来实现。"),s("code",[t._v("copyWithZone")]),t._v(" 方法的实现需要在新对象中复制原始对象的属性和数据, 以便新对象也能正确工作。NSZone 参数通常可以被忽略, 除非你有特定的需求。")]),t._v(" "),s("p",[t._v("遵循 NSCopying 协议的对象通常是不可变的, 因为它们的内容在复制后不能被修改。这在 Objective-C 中非常有用, 因为你可以创建一个原始对象的不可变副本, 以确保数据的安全性和不可修改性。")]),t._v(" "),s("p",[t._v("在实际开发中, 如果你定义了一个自定义的 Objective-C 类, 而你希望该类的实例能够进行复制操作, 你可以让该类遵循 NSCopying 协议, 并实现 "),s("code",[t._v("copyWithZone")]),t._v(" 方法来定义如何复制对象的行为。这对于创建对象的副本, 而不改变原始对象的状态非常有用。")]),t._v(" "),s("h3",{attrs:{id:"字符串-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#字符串-2"}},[t._v("#")]),t._v(" 字符串")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("NSString")]),t._v(": The basic NSString class is immutable")]),t._v(" "),s("li",[s("code",[t._v("NSMutableString")]),t._v(": The NSMutableString class is the mutable subclass of NSString")])]),t._v(" "),s("h3",{attrs:{id:"macros-简化代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#macros-简化代码"}},[t._v("#")]),t._v(" macros 简化代码")]),t._v(" "),s("p",[s("strong",[t._v("示例一")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("SVC_VC_SERVICE")]),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PROPERTY"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SERVICE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("SERVICE"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("PROPERTY")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("componentManager getService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@protocol")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SERVICE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")])])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("这段代码是 Objective-C 中的宏定义(#define), 用于定义一个属性宏, 以便通过属性名访问组件或服务。该宏定义会生成一个类的方法, 使开发者能够通过该属性名称直接获取相应的服务对象。")]),t._v(" "),s("p",[t._v("这是一个通用的宏定义, 它包含两个参数:")]),t._v(" "),s("p",[t._v("PROPERTY: 这个参数表示属性的名称, 通常是一个属性的名称字符串。\nSERVICE: 这个参数通常是一个协议名, 它表示你想要获取的服务的类型。\n这个宏定义生成的方法的功能是, 根据给定的服务协议(SERVICE)从 componentManager 中获取相应的服务对象。componentManager 是一个管理组件或服务的对象, 可能是一个单例对象, 它包含了各种服务的实例。这个宏允许你通过属性名直接访问这些服务。")]),t._v(" "),s("p",[t._v("实际使用时, 你可以在类的接口部分使用这个宏, 如下所示:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SVC_VC_SERVICE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("myService"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" MyServiceProtocol"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这会生成一个名为 myService 的属性, 该属性的类型是 "),s("code",[t._v("id<MyServiceProtocol>")]),t._v(", 也就是符合 MyServiceProtocol 协议的对象。在类的实现中, 你就可以使用这个属性来获取相应的服务。")]),t._v(" "),s("p",[t._v("这种宏定义的好处是, 它提供了一种更简洁的方式来获取服务, 而不必在每个需要使用服务的地方都编写繁琐的代码。宏定义可以减少代码的冗余, 提高代码的可维护性。")]),t._v(" "),s("p",[s("strong",[t._v("示例二")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("LMJWeak")]),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  __weak "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typeof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("type"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" weak")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("##")]),s("span",{pre:!0,attrs:{class:"token expression"}},[t._v("type "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" type")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("ul",[s("li",[s("p",[s("code",[t._v("__weak")]),t._v(" 是 Objective-C 中的关键字, 用于声明一个弱引用。它创建一个指向对象的弱引用, 不会增加对象的引用计数, 从而避免了循环引用的问题。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("weak##type")]),t._v(" 中的 "),s("code",[t._v("##")]),t._v(" 是一个连接符, 用于将 weak 和 type 连接在一起, 从而创建一个带有 type 名称前缀的弱引用变量。这样, "),s("code",[t._v("weak##type")]),t._v(" 就成为了一个以 weak 为前缀、后面跟着 type 名称的弱引用变量, 例如 weakself 或 weakobject。")])])]),t._v(" "),s("p",[t._v("所以, 这个宏定义的作用是为了创建一个带有指定前缀的弱引用变量, 可以根据 type 参数的不同, 生成不同的变量名。这有助于在 block 内部安全地引用对象, 避免循环引用。")]),t._v(" "),s("h3",{attrs:{id:"protocol-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protocol-关键字"}},[t._v("#")]),t._v(" "),s("code",[t._v("@protocol")]),t._v(" 关键字")]),t._v(" "),s("blockquote",[s("p",[t._v("更多内容请点击:  "),s("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html#//apple_ref/doc/uid/TP40011210-CH11-SW1",target:"_blank",rel:"noopener noreferrer"}},[t._v("协议"),s("OutboundLink")],1)])]),t._v(" "),s("p",[s("code",[t._v("@protocol")]),t._v(" 是 Objective-C 中的一个关键字, 用于定义协议(Protocol)。Protocols can include declarations for both instance methods and class methods, as well as properties.")]),t._v(" "),s("p",[t._v("基础语法如下:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@protocol")]),t._v(" ProtocolName\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// list of methods and properties")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("Objective-C 中的协议类似于其他编程语言中的接口(Interface)或抽象类(Abstract Class), 它们用于描述类应该具有的特定行为, 但不提供实际的代码实现。协议在 Objective-C 中具有以下\n特点:")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("**声明方法和属性: **: 协议可以包含一组方法和属性的声明, 但不提供实际的方法体或属性实现。这些声明在协议中只是描述, 没有具体代码。")])]),t._v(" "),s("li",[s("p",[t._v("**可选或强制实现: **: 协议中的方法可以被标记为可选或强制实现。强制实现的方法必须在遵循协议的类中提供具体的实现, 而可选方法可以选择性地实现。这为类提供了一定的灵活性。")])]),t._v(" "),s("li",[s("p",[t._v("**多继承: **: Objective-C 支持多重继承, 一个类可以遵循多个不同的协议。这允许类获得来自多个协议的行为。")])]),t._v(" "),s("li",[s("p",[t._v("**委托模式: **: 协议常用于实现委托模式, 其中一个对象委托另一个对象执行某些任务。例如, UIKit 中的代理(Delegate)通常是协议的实现。")])]),t._v(" "),s("li",[s("p",[t._v("**面向协议编程: **: Objective-C 通过协议支持面向协议编程, 这种编程风格侧重于对象之间的通信和合作, 而不仅仅是类的继承关系。")])])]),t._v(" "),s("p",[t._v("定义一个协议示例:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@protocol")]),t._v(" MyProtocol "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("NSObject"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),t._v("required\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("requiredMethod"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),t._v("optional\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("optionalMethod"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("在上面的示例中, MyProtocol 定义了两个方法: requiredMethod 是一个强制实现的方法, 而 optionalMethod 是一个可选方法。类可以遵循该协议并提供这些方法的具体实现。")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("<NSObject>")]),t._v(": 这是一个协议的继承。通过继承自 NSObject 协议, MyProtocol 协议将继承 NSObject 协议中定义的方法和属性。这包括了 Objective-C 中的基本对象操作, 例如内存管理和方法调用。")])]),t._v(" "),s("p",[t._v("遵循协议的示例:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@interface")]),t._v(" MyClass "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" NSObject "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("MyProtocol"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("p",[t._v("上述代码表示 MyClass 类遵循了 MyProtocol 协议, 因此它必须提供 requiredMethod 方法的具体实现, 而 optionalMethod 是可选的。")]),t._v(" "),s("p",[t._v("协议在 Objective-C 中是一种非常强大和灵活的特性, 它使得不同类可以共享一组通用的行为规范, 从而提高了代码的重用性和可维护性。")]),t._v(" "),s("h3",{attrs:{id:"protocol-与-interface"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protocol-与-interface"}},[t._v("#")]),t._v(" "),s("code",[t._v("@protocol")]),t._v(" 与 "),s("code",[t._v("@interface")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("Objective-C 中的协议 ("),s("code",[t._v("@protocol")]),t._v("), 相当于 C#, Java 等语言中的接口 (Interface)。协议本身不实现任何方法, 只是声明方法, 使用协议的类必须实现协议方法。")])]),t._v(" "),s("li",[s("p",[t._v("Objective-C 中的接口 ("),s("code",[t._v("@interface")]),t._v("), 相当于 C#, Java 等语言中的类(Class), 是类的一个声明, 不同与 C#, Java 等语言的接口。")])]),t._v(" "),s("li",[s("p",[t._v("Objective-C 中的类必须要有接口, 但不一定都要有协议。使用协议的类, 必须实现协议中的方法。")])]),t._v(" "),s("li",[s("p",[t._v("Objective-C 中的父类中如果已经使用了协议 ("),s("code",[t._v("@protocol")]),t._v("), 并实现了协议中的方法, 那么其子类就要添加相同的协议 ("),s("code",[t._v("@protocol")]),t._v("), 也不需要再重复实现协议中的方法, 除非必要。这和 C#, Java, 等语言中的接口 (Interface) 使用方法一致。")])])]),t._v(" "),s("h3",{attrs:{id:"define-class"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#define-class"}},[t._v("#")]),t._v(" define class")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("- (void)someMethodWithFirstValue:(SomeType)value1 secondValue:(AnotherType)value2;")]),t._v(": 类的定义")])]),t._v(" "),s("p",[s("strong",[t._v("初始化方法")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("instancetype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("init "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),t._v(" init"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Call the designated initializer of the superclass.")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Initialize your object's properties and perform setup here.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("property1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" defaultValue1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("property2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" defaultValue2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("h3",{attrs:{id:"property-定义属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#property-定义属性"}},[t._v("#")]),t._v(" "),s("code",[t._v("@property")]),t._v(" "),s("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html#//apple_ref/doc/uid/TP40011210-CH5-SW2",target:"_blank",rel:"noopener noreferrer"}},[t._v("定义属性"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("strong",[t._v("语法")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("assign"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nonatomic"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" Class destVc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("strong",[t._v("修饰")])]),t._v(" "),s("ul",[s("li",[s("code",[t._v("nonatomic")]),t._v(": it’s faster to access a nonatomic property than an atomic one")]),t._v(" "),s("li",[s("code",[t._v("assign")]),t._v(": 通常用于修饰基本数据类型的属性, 例如整数 (int)、浮点数 (float)、指针等。它告诉编译器在设置属性的新值时不要自动处理内存管理, 仅仅是简单地赋值\n"),s("ul",[s("li",[t._v("【注】在使用 assign 修饰符时, 你需要特别小心, 确保不会在属性引用的对象被释放后再次访问该属性, 因为它不会自动设置属性为 nil。这可能导致悬垂指针或访问已释放内存的问题。因此, assign 修饰符通常在非对象类型的属性上使用, 而对象属性通常使用更安全的修饰符, 以自动处理内存管理。")])])]),t._v(" "),s("li",[s("code",[t._v("readonly")]),t._v(": don’t want to allow a property to be changed via a setter method")]),t._v(" "),s("li",[s("code",[t._v("readwrite")]),t._v(": default")]),t._v(" "),s("li",[s("code",[t._v("getter=isFinished")]),t._v(": use a different name for an accessor method")])]),t._v(" "),s("hr"),t._v(" "),s("p",[s("strong",[t._v("属性的"),s("code",[t._v("set/get")]),t._v("方法")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("UITableView "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("tableView\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("_tableView "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        UITableView "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("tableView "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("UITableView alloc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" initWithFrame"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("view"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("bounds style"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tableViewStyle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("view addSubview"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("tableView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        tableView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("autoresizingMask "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" UIViewAutoresizingFlexibleWidth "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" UIViewAutoresizingFlexibleHeight"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        _tableView "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tableView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" _tableView"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("这是一个属性的自定义 getter 方法。在 Objective-C 中, 当你使用 "),s("code",[t._v("@property")]),t._v(" 声明一个属性时, 编译器会自动为你生成 "),s("code",[t._v("getter")]),t._v(" 和 "),s("code",[t._v("setter")]),t._v(" 方法, 但你也可以自定义它们, 以实现特定的行为。")]),t._v(" "),s("p",[t._v("在你提供的代码中, 你自定义了 tableView 属性的 getter 方法。这个 getter 方法首先检查 _tableView 是否为 nil, 如果是 nil, 则创建一个新的 UITableView 对象, 将其添加到视图中, 设置自动调整大小的属性, 然后将它赋值给 _tableView。最后, 它返回 _tableView。")]),t._v(" "),s("p",[t._v("这种方式常用于懒加载(lazy loading), 即只有在首次访问属性时才会创建和初始化对象, 以节省资源和提高性能。如果 _tableView 已经被初始化过, 那么它将直接返回已存在的对象, 避免重复创建。")]),t._v(" "),s("p",[t._v("所以, 这是属性的 getter 方法, 用于获取 tableView 属性的值。")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"nsarray"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nsarray"}},[t._v("#")]),t._v(" NSArray")]),t._v(" "),s("blockquote",[s("p",[t._v("解释 "),s("code",[t._v("NSMutableArray *mulArray = @[].mutableCopy;")])])]),t._v(" "),s("p",[t._v("这行代码创建了一个可变数组对象 mulArray, 并使用数组字面量语法(@[])初始化它, 然后通过 mutableCopy 方法创建了 mulArray 的可变副本。让我一步一步解释这行代码:")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("@[]")]),t._v(": 这是 Objective-C 中的数组字面量语法。它创建一个空的不可变数组。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v(".mutableCopy")]),t._v(": 这是一个方法调用, 应用于不可变数组上, 用于创建一个可变数组的副本。在这里, "),s("code",[t._v("@[]")]),t._v(" 创建的不可变数组被复制为一个可变数组。")])])]),t._v(" "),s("p",[t._v("所以, "),s("code",[t._v("NSMutableArray *mulArray")]),t._v(" 保存了一个空的可变数组, 你可以随后向它添加元素, 使其动态地扩展和管理数据。这种方式通常用于初始化一个可变容器, 以后可以根据需要向其中添加或删除元素。")]),t._v(" "),s("h3",{attrs:{id:"ns-enum-宏定义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ns-enum-宏定义"}},[t._v("#")]),t._v(" NS_ENUM 宏定义")]),t._v(" "),s("p",[s("code",[t._v("NS_ENUM")]),t._v(" 不是一个关键字, 它是一个宏, 用于定义带有命名常数的枚举。这个宏的目的是帮助开发人员更容易地创建具有特定类型的枚举。")]),t._v(" "),s("p",[t._v("以下是 "),s("code",[t._v("NS_ENUM")]),t._v(" 的一般语法:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NS_ENUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("枚举的底层类型"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 枚举名"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    枚举成员"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    枚举成员"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("举例说明")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("NS_ENUM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("NSUInteger"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" VideoComponentSceneType"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    VideoComponentSceneOfRecommend "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    VideoComponentSceneLandScape "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 横竖屏")]),t._v("\n    VideoComponentSceneImageCollection "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 图集")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("ul",[s("li",[s("code",[t._v("NSUInteger")]),t._v(": 底层类型是")])]),t._v(" "),s("h3",{attrs:{id:"基本数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[t._v("#")]),t._v(" 基本数据类型")]),t._v(" "),s("p",[t._v("Objective-C 是一种面向对象的编程语言, 它建立在 C 语言的基础上, 并扩展了 C 以支持面向对象编程。在 Objective-C 中, 有一些基本数据类型, 包括:")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("NSInteger 和 NSUInteger")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("NSInteger")]),t._v(" 表示有符号整数, 通常用于存储整数值, 包括正数和负数。")]),t._v(" "),s("li",[s("code",[t._v("NSUInteger")]),t._v(" 表示无符号整数, 通常用于存储正数值。这两种类型的大小(位数)取决于底层操作系统的架构, 可以是 32 位或 64 位。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("BOOL")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("BOOL")]),t._v(" 是布尔数据类型, 它只有两个值: YES 和 NO, 分别表示真和假。在 C 语言中, 这相当于 1 和 0。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("CGFloat")]),t._v(" 和 "),s("strong",[t._v("double")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("CGFloat")]),t._v(" 表示浮点数, 通常用于存储小数值, 例如浮点数或双精度浮点数。")]),t._v(" "),s("li",[s("code",[t._v("double")]),t._v(" 是 C 语言中的浮点数据类型, 也用于存储小数值, 但具有更高的精度。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("char")]),t._v(" 和 "),s("strong",[t._v("NSString")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("char")]),t._v(" 用于表示字符, 通常用于处理字符和字符串。")]),t._v(" "),s("li",[s("code",[t._v("NSString")]),t._v(" 是 Objective-C 中的字符串类型, 用于存储和操作文本数据。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("id")]),t._v(":")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("id")]),t._v(" 是一个泛型对象指针, 可以引用任何 Objective-C 对象。这使得 Objective-C 具有动态类型的特性。")])])])]),t._v(" "),s("p",[t._v("这些基本数据类型都是 Objective-C 语言的一部分, 你可以使用它们来声明和操作不同类型的数据。另外, Objective-C 还提供了许多复杂的数据类型, 如数组、字典、集合等, 用于处理更复杂的数据结构。")]),t._v(" "),s("h3",{attrs:{id:"复杂数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#复杂数据类型"}},[t._v("#")]),t._v(" 复杂数据类型")]),t._v(" "),s("p",[t._v("在 Objective-C 中, 你可以使用复杂的数据类型来表示更复杂的数据结构, 这些数据类型通常是基于 Objective-C 对象的。以下是一些常见的复杂数据类型:")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("NSArray")]),t._v(": NSArray 是一个有序的集合, 可以包含多个对象, 对象类型可以不同。它是不可变的, 一旦初始化, 其内容不可更改。对应的可变版本是 NSMutableArray, 可以动态添加、删除、替换其中的元素。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NSDictionary")]),t._v(": NSDictionary 是一个键-值对的集合, 可以将键映射到相应的值。它也是不可变的, 对应的可变版本是 NSMutableDictionary。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NSSet")]),t._v(": NSSet 是一个无序的集合, 用于存储一组唯一的对象。它是不可变的, 对应的可变版本是 NSMutableSet。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NSData")]),t._v(": NSData 表示原始的二进制数据, 通常用于文件操作、网络传输等。有可变版本 NSMutableData, 允许修改数据。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NSString")]),t._v(": NSString 表示字符串数据。Objective-C 内置了对字符串的支持, 包括字符串的创建、连接、截取、查找等一系列操作。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("NSArray、NSDictionary、NSSet")]),t._v(": 是集合类, 它们可以嵌套使用, 从而创建更复杂的数据结构。例如, 你可以创建一个包含字典的数组, 或者字典中包含其他数组, 以满足你的数据组织需求。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("自定义对象")]),t._v(": 你还可以定义自己的复杂数据类型, 通过创建 Objective-C 类, 这些类可以包含属性、方法、实例变量等。这些自定义类可以用来表示更复杂的数据结构, 比如用户、产品、订单等。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("枚举类型")]),t._v(": Objective-C 也支持枚举, 你可以用它来定义一组离散的值, 用于表示有限的选项, 例如颜色、状态等。")])]),t._v(" "),s("li",[s("p",[t._v("**结构体: 虽然 Objective-C 主要是基于面向对象的编程, 但它也支持 C 语言的结构体, 你可以使用结构体来组织一组相关的数据。")])])]),t._v(" "),s("p",[t._v("总之, Objective-C 提供了多种数据类型和数据结构, 允许你灵活地表示和操作各种复杂数据。你可以根据你的应用程序需求选择合适的数据类型。")]),t._v(" "),s("h3",{attrs:{id:"sel"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sel"}},[t._v("#")]),t._v(" SEL")]),t._v(" "),s("blockquote",[s("p",[t._v("更多"),s("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1185867",target:"_blank",rel:"noopener noreferrer"}},[t._v("查看"),s("OutboundLink")],1)])]),t._v(" "),s("p",[t._v("我们要首先明白 SEL, SEL 并不是一种对象类型, 我们通过 xCode 的字体颜色就可以判断出来, 它是一个关键字, 就像 int, long 一样, 它声明了一种类型: 类方法指针。其实就可以理解为一个"),s("strong",[t._v("函数指针")])]),t._v(" "),s("h3",{attrs:{id:"符号-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号-2"}},[t._v("#")]),t._v(" ^ 符号")]),t._v(" "),s("blockquote",[s("p",[t._v("return 后面的^符号")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LMJStaticTableViewController "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LMJWordItem "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("addItem "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("LMJWeak")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sections"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sections addObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("LMJItemSection sectionWithItems"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("@")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" andHeaderTitle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("nil footerTitle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("LMJStaticTableViewController "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("LMJWordItem "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("weakself"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sections"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("firstObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("items addObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("item"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" weakself"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br")])]),s("p",[t._v("在 Objective-C 中, "),s("code",[t._v("^")]),t._v(" 符号表示一个 block 对象的开始, 也称为 block 语法。在你的代码中, return 后面的 "),s("code",[t._v("^")]),t._v(" 符号用于定义一个 block。这个 block 接受一个 LMJWordItem 类型的参数 item, 并返回一个 LMJStaticTableViewController 对象。")]),t._v(" "),s("p",[t._v("这种语法允许你创建一个能够在后续代码中执行的闭包, 这个闭包可以包含你定义的逻辑。在这个特定的情况下, 这个闭包用于向 LMJStaticTableViewController 的 sections 中添加 LMJWordItem 对象。")]),t._v(" "),s("p",[t._v("这是一种非常强大的模式, 通常用于链式调用 API, 其中你可以依次添加多个元素或配置参数, 并且在代码中保持良好的可读性和流畅性。")]),t._v(" "),s("h3",{attrs:{id:"返回闭包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#返回闭包"}},[t._v("#")]),t._v(" 返回闭包")]),t._v(" "),s("p",[s("code",[t._v("- (LMJStaticTableViewController *(^)(LMJWordItem *))addItem {}")])]),t._v(" "),s("p",[t._v("这是一个 Objective-C 方法的声明, 它具有以下特点:")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("返回类型")]),t._v(": "),s("code",[t._v("LMJStaticTableViewController _(^)(LMJWordItem _)")]),t._v(" 表示这个方法返回一个 block 对象, 该 block 接受一个 LMJWordItem 类型的参数, 并返回一个 LMJStaticTableViewController 对象。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("方法名称")]),t._v(": addItem 是这个方法的名称。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("方法参数")]),t._v(": 这个方法没有显式的参数, 但它返回的 block 对象具有一个参数, 即 LMJWordItem 类型的对象。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("返回值")]),t._v(": 返回一个 block 对象, 该 block 接受 LMJWordItem 类型的参数, 然后返回 LMJStaticTableViewController 对象。")])])]),t._v(" "),s("h3",{attrs:{id:"uitableview"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uitableview"}},[t._v("#")]),t._v(" UITableView")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("NSIndexPath")]),t._v(": <>")])]),t._v(" "),s("h3",{attrs:{id:"selector-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#selector-关键字"}},[t._v("#")]),t._v(" "),s("code",[t._v("@selector")]),t._v(" 关键字")]),t._v(" "),s("p",[t._v("在 Objective-C 中, "),s("code",[t._v("@selector")]),t._v(" 是一个关键字, 用于创建一个选择器对象, 它通常用于表示方法名称。在上述代码中, "),s("code",[t._v("@selector(runExitAction)")]),t._v(" 创建了一个选择器, 表示名为 runExitAction 的方法。")]),t._v(" "),s("p",[t._v("选择器对象通常用于以下几种情况:")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("作为方法的参数: 你可以将选择器作为参数传递给某个方法, 以便在运行时动态调用特定的方法。")])]),t._v(" "),s("li",[s("p",[t._v("作为键: 选择器可以作为 NSDictionary 或其他数据结构中的键, 用于关联方法和其他数据。")])]),t._v(" "),s("li",[s("p",[t._v("用于比较: 你可以使用选择器来比较两个方法是否相同。")])])]),t._v(" "),s("p",[s("strong",[t._v("代码示例")])]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("ExitThread\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    _myThread "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("myThread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("myThread"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("NSThread alloc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("initWithTarget"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" selector"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@selector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("runExitAction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" object"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("nil"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("myThread"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('@"thread-exit"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("myThread start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br")])]),s("p",[t._v("在上面的代码中, "),s("code",[t._v("@selector(runExitAction)")]),t._v(" 创建了一个选择器, 用于表示 runExitAction 方法。一旦你有了这个选择器, 你可以使用它来执行或比较方法。在创建线程时, 你指定了这个选择器作为线程的执行点, 这意味着线程将在后台执行 runExitAction 方法中的代码。")]),t._v(" "),s("h3",{attrs:{id:"符号-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#符号-3"}},[t._v("#")]),t._v(" [...] 符号")]),t._v(" "),s("blockquote",[s("p",[s("code",[t._v("item27.destVc = [LMJNavBarFadeViewController class];")])])]),t._v(" "),s("p",[t._v("在 Objective-C 中, 中括号 "),s("code",[t._v("[...]")]),t._v(" 用于消息传递的语法。Objective-C 是一门基于消息传递的编程语言, 与其他语言的方法调用语法略有不同。下面是对你提供的代码的解释:")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[t._v("item27"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("destVc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("LMJNavBarFadeViewController class"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("这行代码的含义是设置 item27 对象的 destVc 属性为 LMJNavBarFadeViewController 类。在这里, 中括号用于向 class 方法发送消息, 获取 LMJNavBarFadeViewController 类的对象。这通常用于获取类的信息或执行类方法。")]),t._v(" "),s("p",[t._v("总结起来, 中括号 "),s("code",[t._v("[...]")]),t._v(" 在 Objective-C 中用于向对象发送消息, 包括方法调用、属性设置和获取等操作")]),t._v(" "),s("h3",{attrs:{id:"属性说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属性说明"}},[t._v("#")]),t._v(" "),s("code",[t._v("_")]),t._v(" 属性说明")]),t._v(" "),s("div",{staticClass:"language-objc line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-objc"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@interface")]),t._v(" LMJCountDownCell "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" UITableViewCell\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** <#digest#> */")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@property")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("nonatomic"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" strong"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" LMJCountDownModel "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("countDownModel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("@end")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("p",[t._v("在 Objective-C 中, 通常使用下划线 "),s("code",[t._v("_")]),t._v(" 作为实例变量的前缀, 而不是直接访问属性。这是一种编码风格的约定, 有助于区分属性和实例变量, 以及避免潜在的命名冲突。")]),t._v(" "),s("p",[t._v("在你的代码中, "),s("code",[t._v("@property")]),t._v(" 声明了一个属性 countDownModel, 但这个属性在底层是由编译器自动生成的实例变量, 实例变量的名称是在属性名称前加下划线 "),s("code",[t._v("_")]),t._v(", 即 "),s("code",[t._v("_countDownModel")]),t._v("。这个实例变量用于在类内部存储属性的值。")]),t._v(" "),s("p",[t._v("所以, 当你在类的方法中使用 "),s("code",[t._v("_countDownModel")]),t._v(" 进行赋值或访问时, 你实际上在直接访问实例变量, 而不是通过属性的 "),s("code",[t._v("getter")]),t._v(" 和 "),s("code",[t._v("setter")]),t._v(" 方法。这种做法有助于避免属性访问器方法的递归调用和潜在的命名冲突。")]),t._v(" "),s("p",[t._v("通常, 属性的 getter 方法会自动访问相应的实例变量, 所以在类的内部, 你可以直接访问实例变量来避免额外的性能开销。但在类的外部, 应该使用属性来访问和修改属性的值, 以确保属性的封装性和数据完整性。这也是为什么通常在属性的 "),s("code",[t._v("getter")]),t._v(" 方法中使用 "),s("code",[t._v("self.propertyName")]),t._v(" 而在类内部使用 "),s("code",[t._v("self->_propertyName")]),t._v(" 或 "),s("code",[t._v("_propertyName")]),t._v(" 的原因。")])])}),[],!1,null,null,null);s.default=n.exports}}]);