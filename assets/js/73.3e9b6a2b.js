(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{392:function(t,e,a){"use strict";a.r(e);var r=a(4),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"websocket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" WebSocket")]),t._v(" "),e("blockquote",[e("p",[t._v("WebSocket, 下层和 HTTP 一样也是基于 TCP 协议, 是一种轻量级网络通信协议, 也属于应用层协议。")]),t._v(" "),e("p",[t._v('WebSocket 与 HTTP/2 一样, 其实都是为了解决 HTTP/1.1 的一些缺陷而诞生的, 而 WebSocket 针对的就是「请求-应答」这种"半双工"的模式的通信缺陷。')])]),t._v(" "),e("h3",{attrs:{id:"附件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#附件"}},[t._v("#")]),t._v(" 附件")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/ad-ppp/WsManager",target:"_blank",rel:"noopener noreferrer"}},[t._v("基于Okhttp的WebSocket示例-WsManager"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1719385",target:"_blank",rel:"noopener noreferrer"}},[t._v("使用Android WebSocket实现即时通讯功能"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"socket"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[t._v("#")]),t._v(" Socket")]),t._v(" "),e("blockquote",[e("p",[t._v("网络中的 Socket 并不是什么协议, 而是为了使用 TCP, UDP 而抽象出来的一层 API, 它是位于应用层和传输层之间的一个抽象层。")])]),t._v(" "),e("hr"),t._v(" "),e("h3",{attrs:{id:"常见问题汇总"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见问题汇总"}},[t._v("#")]),t._v(" 常见问题汇总")]),t._v(" "),e("h4",{attrs:{id:"半包-粘包与分包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#半包-粘包与分包"}},[t._v("#")]),t._v(" 半包, 粘包与分包")]),t._v(" "),e("p",[t._v("一个包没有固定长度, 以太网限制在46－1500字节, 1500就是以太网的MTU, 超过这个量, TCP会为IP数据报设置偏移量进行分片传输, 现在一般可允许应用层设置8k(NTFS系)的缓冲区, 8k的数据由底层分片, 而应用看来只是一次发送。windows的缓冲区经验值是4k,Socket本身分为两种, 流(TCP)和数据报(UDP), 你的问题针对这两种不同使用而结论不一样。甚至还和你是用阻塞、还是非阻塞Socket来编程有关.\n注意一点, 你无论发多大的包, IP层和链路层都会把你的包进行分片发送, 一般局域网就是1500左右")]),t._v(" "),e("h4",{attrs:{id:"tcp的三次握手与四次挥手"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手与四次挥手"}},[t._v("#")]),t._v(" TCP的三次握手与四次挥手")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://www.huaweicloud.com/articles/eedcc3d1fe20c890bfa0c960781f0ab1.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("内容来自华为云分析"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/jacky1234/picArchieve/master/uPic/0c6f5dc04e337b1c6deb57e82a9210d71603427626959.jpeg",alt:"TCP协议: 三次握手、四次挥手过程详解1"}})]),t._v(" "),e("h5",{attrs:{id:"三次握手建立连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三次握手建立连接"}},[t._v("#")]),t._v(" 三次握手建立连接")]),t._v(" "),e("p",[t._v("第一次握手: 客户端发送syn包(seq=x)到服务器, 并进入SYN_SEND状态, 等待服务器确认;")]),t._v(" "),e("p",[t._v("第二次握手: 服务器收到syn包, 必须确认客户的SYN(ack=x+1), 同时自己也发送一个SYN包(seq=y), 即SYN+ACK包, 此时服务器进入SYN_RECV状态;")]),t._v(" "),e("p",[t._v("第三次握手: 客户端收到服务器的SYN+ACK包, 向服务器发送确认包ACK(ack=y+1), 此包发送完毕, 客户端和服务器进入ESTABLISHED状态, 完成三次握手。")]),t._v(" "),e("p",[t._v("握手过程中传送的包里不包含数据, 三次握手完毕后, 客户端与服务器才正式开始传送数据。理想状态下, TCP连接一旦建立, 在通信双方中的任何一方主动关闭连接之前, TCP 连接都将被一直保持下去。")]),t._v(" "),e("p",[t._v("**传输数据过程: **")]),t._v(" "),e("p",[t._v("a.超时重传超时重传机制用来保证TCP传输的可靠性。每次发送数据包时, 发送的数据报都有seq号, 接收端收到数据后, 会回复ack进行确认, 表示某一seq 号数据已经收到。发送方在发送了某个seq包后, 等待一段时间, 如果没有收到对应的ack回复, 就会认为报文丢失, 会重传这个数据包。")]),t._v(" "),e("p",[t._v("b."),e("strong",[t._v("快速重传")]),t._v("接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包, 则会触发客户端的快速重 传。比较超时重传和快速重传, 可以发现超时重传是发送端在傻等超时, 然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到, 然后触发发送端重传。")]),t._v(" "),e("p",[t._v("c.流量控制这里主要说"),e("strong",[t._v("TCP滑动窗流量控制")]),t._v("。TCP头里有一个字段叫Window, 又叫Advertised-Window, 这个字段是接收端告诉发送端自己 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据, 而不会导致接收端处理不过来。 滑动窗可以是提高TCP传输效率的一种机制。")]),t._v(" "),e("p",[t._v('d.拥塞控制滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况, 而没有考虑整个网络的通信情况。拥塞控制, 则是基于整个网络来考虑的。考虑一下这 样的场景: 某一时刻网络上的延时突然增加, 那么, TCP对这个事做出的应对只有重传数据, 但是, 重传会导致网络的负担更重, 于是会导致更大的延迟以及更多 的丢包, 于是, 这个情况就会进入恶性循环被不断地放大。试想一下, 如果一个网络内有成千上万的TCP连接都这么行事, 那么马上就会形成"网络风 暴", TCP这个协议就会拖垮整个网络。为此, '),e("strong",[t._v("TCP引入了拥塞控制策略")]),t._v("。拥塞策略算法主要包括: 慢启动, 拥塞避免, 拥塞发生, 快速恢复。")]),t._v(" "),e("h5",{attrs:{id:"四次握手断开连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四次握手断开连接"}},[t._v("#")]),t._v(" 四次握手断开连接")]),t._v(" "),e("p",[t._v("第一次挥手: 主动关闭方发送一个FIN, 用来关闭主动方到被动关闭方的数据传送, 也就是主动关闭方告诉被动关闭方: 我已经不会再给你发数据了(当 然, 在fin包之前发送出去的数据, 如果没有收到对应的ack确认报文, 主动关闭方依然会重发这些数据), 但此时主动关闭方还可以接受数据。")]),t._v(" "),e("p",[t._v("第二次挥手: 被动关闭方收到FIN包后, 发送一个ACK给对方, 确认序号为收到序号+1(与SYN相同, 一个FIN占用一个序号)。")]),t._v(" "),e("p",[t._v("第三次挥手: 被动关闭方发送一个FIN, 用来关闭被动关闭方到主动关闭方的数据传送, 也就是告诉主动关闭方, 我的数据也发送完了, 不会再给你发数据了。")]),t._v(" "),e("p",[t._v("第四次挥手: 主动关闭方收到FIN后, 发送一个ACK给被动关闭方, 确认序号为收到序号+1, 至此, 完成四次挥手。")]),t._v(" "),e("hr"),t._v(" "),e("h2",{attrs:{id:"websocket-与-socket-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#websocket-与-socket-区别"}},[t._v("#")]),t._v(" WebSocket 与 Socket 区别")]),t._v(" "),e("ol",[e("li",[t._v("Socket 是传输控制层的接口。用户可以通过 Socket 来操作底层 TCP/IP 协议族通信。")]),t._v(" "),e("li",[t._v("WebSocket 是一个完整应用层协议。")]),t._v(" "),e("li",[t._v("Socket 更灵活, WebSocket 更易用。")]),t._v(" "),e("li",[t._v("两者都能做即时通讯")])])])}),[],!1,null,null,null);e.default=s.exports}}]);