(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{411:function(a,t,v){"use strict";v.r(t);var r=v(4),l=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"thread"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#thread"}},[a._v("#")]),a._v(" thread")]),a._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/java1024/p/13390538.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://www.cnblogs.com/java1024/p/13390538.html"),t("OutboundLink")],1),a._v(" "),t("RouterLink",{attrs:{to:"/pages/9969c2/"}},[a._v("link")])],1)]),a._v(" "),t("ol",[t("li",[a._v("现在有 T1、T2、T3 三个线程，你怎样保证 T2 在 T1 执行完后执行，T3 在 T2 执行完后执行？")])]),a._v(" "),t("p",[a._v('这个线程问题通常会在第一轮或电话面试阶段被问到，目的是检测你对"join"方法是否熟悉。这个多线程问题比较简单，可以用 join 方法实现。')]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("在 Java 中 Lock 接口比 synchronized 块的优势是什么？你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？")])]),a._v(" "),t("p",[a._v("lock 接口在多线程和并发编程中最大的优势是它们为读和写分别提供了锁，它能满足你写像 ConcurrentHashMap 这样的高性能数据结构和有条件的阻塞。Java 线程面试的问题越来越会根据面试者的回答来提问。我强烈建议在你去参加多线程的面试之前认真读一下 Locks，因为当前其大量用于构建电子交易终统的客户端缓存和交易连接空间。")]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("在 java 中 wait 和 sleep 方法的不同？")])]),a._v(" "),t("p",[a._v("通常会在电话面试中经常被问到的 Java 线程面试问题。最大的不同是在等待时 wait 会释放锁，而 sleep 一直持有锁。Wait 通常被用于线程间交互，sleep 通常被用于暂停执行。")]),a._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[a._v("用 Java 实现阻塞队列。")])]),a._v(" "),t("p",[a._v("这是一个相对艰难的多线程面试问题，它能达到很多的目的。第一，它可以检测侯选者是否能实际的用 Java 线程写程序；第二，可以检测侯选者对并发场景的理解，并且你可以根据这个问很多问题。如果他用 wait()和 notify()方法来实现阻塞队列，你可以要求他用最新的 Java 5 中的并发类来再写一次。")]),a._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[a._v("用 Java 写代码来解决生产者——消费者问题。")])]),a._v(" "),t("p",[a._v("与上面的问题很类似，但这个问题更经典，有些时候面试都会问下面的问题。在 Java 中怎么解决生产者——消费者问题，当然有很多解决方法，我已经分享了一种用阻塞队列实现的方法。有些时候他们甚至会问怎么实现哲学家进餐问题。")]),a._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[a._v("用 Java 编程一个会导致死锁的程序，你将怎么解决？")])]),a._v(" "),t("p",[a._v("这是我最喜欢的 Java 线程面试问题，因为即使死锁问题在写多线程并发程序时非常普遍，但是很多侯选者并不能写 deadlock free code(无死锁代码？)，他们很挣扎。只要告诉他们，你有 N 个资源和 N 个线程，并且你需要所有的资源来完成一个操作。为了简单这里的 n 可以替换为 2，越大的数据会使问题看起来更复杂。通过避免 Java 中的死锁来得到关于死锁的更多信息。")]),a._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[a._v("什么是原子操作，Java 中的原子操作是什么？")])]),a._v(" "),t("p",[a._v("非常简单的 java 线程面试问题，接下来的问题是你需要同步一个原子操作。")]),a._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[a._v("Java 中的 volatile 关键是什么作用？怎样使用它？在 Java 中它跟 synchronized 方法有什么不同？")])]),a._v(" "),t("p",[a._v("自从 Java 5 和 Java 内存模型改变以后，基于 volatile 关键字的线程问题越来越流行。应该准备好回答关于 volatile 变量怎样在并发环境中确保可见性、顺序性和一致性。")]),a._v(" "),t("p",[a._v("欢迎关注我的公中浩【程序员追风】，文章都会在里面更新，整理的资料也都会放在里面。")]),a._v(" "),t("ol",{attrs:{start:"9"}},[t("li",[a._v("什么是竞争条件？你怎样发现和解决竞争？")])]),a._v(" "),t("p",[a._v("这是一道出现在多线程面试的高级阶段的问题。大多数的面试官会问最近你遇到的竞争条件，以及你是怎么解决的。有些时间他们会写简单的代码，然后让你检测出代码的竞争条件。可以参考我之前发布的关于 Java 竞争条件的文章。在我看来这是最好的 java 线程面试问题之一，它可以确切的检测候选者解决竞争条件的经验，or writing code which is free of data race or any other race condition。关于这方面最好的书是《Concurrency practices in Java》。")]),a._v(" "),t("ol",{attrs:{start:"10"}},[t("li",[a._v("你将如何使用 thread dump？你将如何分析 Thread dump？")])]),a._v(" "),t("p",[a._v('在 UNIX 中你可以使用 kill -3，然后 thread dump 将会打印日志，在 windows 中你可以使用"CTRL+Break"。非常简单和专业的线程面试问题，但是如果他问你怎样分析它，就会很棘手。')]),a._v(" "),t("ol",{attrs:{start:"11"}},[t("li",[a._v("为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？")])]),a._v(" "),t("p",[a._v("这是另一个非常经典的 java 多线程面试问题。这也是我刚开始写线程程序时候的困惑。现在这个问题通常在电话面试或者是在初中级 Java 面试的第一轮被问到。这个问题的回答应该是这样的，当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。")]),a._v(" "),t("ol",{attrs:{start:"12"}},[t("li",[a._v("Java 中你怎样唤醒一个阻塞的线程？")])]),a._v(" "),t("p",[a._v("这是个关于线程和阻塞的棘手的问题，它有很多解决方法。如果线程遇到了 IO 阻塞，我并且不认为有一种方法可以中止线程。如果线程因为调用 wait()、sleep()、或者 join()方法而导致的阻塞，你可以中断线程，并且通过抛出 InterruptedException 来唤醒它。我之前写的《How to deal with blocking methods in java》有很多关于处理线程阻塞的信息。")]),a._v(" "),t("ol",{attrs:{start:"13"}},[t("li",[a._v("在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？")])]),a._v(" "),t("p",[a._v("这个线程问题主要用来检测你是否熟悉 JDK5 中的并发包。这两个的区别是 CyclicBarrier 可以重复使用已经通过的障碍，而 CountdownLatch 不能重复使用。")]),a._v(" "),t("ol",{attrs:{start:"14"}},[t("li",[a._v("什么是不可变对象，它对写并发应用有什么帮助？")])]),a._v(" "),t("p",[a._v("另一个多线程经典面试问题，并不直接跟线程有关，但间接帮助很多。这个 java 面试问题可以变的非常棘手，如果他要求你写一个不可变对象，或者问你为什么 String 是不可变的。")]),a._v(" "),t("ol",{attrs:{start:"15"}},[t("li",[a._v("你在多线程环境中遇到的共同的问题是什么？你是怎么解决它的？")])]),a._v(" "),t("p",[a._v("多线程和并发程序中常遇到的有 Memory-interface、竞争条件、死锁、活锁和饥饿。问题是没有止境的，如果你弄错了，将很难发现和调试。这是大多数基于面试的，而不是基于实际应用的 Java 线程问题。")]),a._v(" "),t("h2",{attrs:{id:"callback-vs-subscription"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#callback-vs-subscription"}},[a._v("#")]),a._v(" callback vs subscription")]),a._v(" "),t("p",[a._v("相比于传统的回调函数(callback)，订阅机制(subscription)在状态管理和事件处理方面具有以下几个关键优势：")]),a._v(" "),t("ol",[t("li",[a._v("解耦合性(Decoupling)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：回调函数通常紧耦合到事件的触发者。这意味着调用方需要显式地将回调函数传递给事件源，并在事件源中管理这些回调。逻辑上，事件源和回调方是紧密联系的。")]),a._v(" "),t("li",[a._v("订阅：订阅机制允许订阅者和发布者之间保持松散耦合。订阅者只需关注自己感兴趣的状态或事件变化，而不需要直接与事件源交互。事件源只负责发布变化，所有的订阅者自动响应更新。这种解耦合提高了代码的模块化和可维护性。")])]),a._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[a._v("管理多个订阅者(Multiple Subscribers Handling)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：使用回调函数时，通常只能绑定单个回调。如果需要处理多个回调，就需要手动管理一个回调列表，这增加了代码复杂性。\n-订阅：订阅机制天生支持多个订阅者，允许不同的地方订阅同一个事件或状态变化。当状态或事件发生变化时，所有的订阅者都会被通知。这为复杂的应用场景(如前端组件树的状态更新)提供了更强的灵活性。")])]),a._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[a._v("自动清理和管理(Automatic Cleanup and Management)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：管理回调的注册和移除是开发者的责任，如果忘记移除回调，可能会导致内存泄漏或不必要的执行。")]),a._v(" "),t("li",[a._v("订阅：许多订阅机制(如 RxJS 或 MobX 中的 observable 模式)提供了自动的订阅管理工具，订阅者可以轻松取消订阅，减少了内存泄漏的风险。比如在 React 中，组件卸载时可以自动取消订阅，防止无效的状态更新。")])]),a._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[a._v("可组合性(Composability)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：回调函数的逻辑较为线性，不易进行复杂的组合操作。如果有多个事件或状态变化需要监控，组合回调的过程可能会非常复杂。")]),a._v(" "),t("li",[a._v("订阅：订阅机制通常可以支持更加复杂的组合操作。例如，多个状态可以组合成一个新的派生状态，并通过订阅该派生状态实现更简洁的反应式更新。像 Recoil、MobX 等状态管理库中，可以通过 selector 或 computed 属性组合多个 atom，从而简化逻辑。")])]),a._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[a._v("更好的状态管理模型(Better State Management Model)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：回调函数倾向于处理即时性的操作，比如处理一个特定的事件响应。随着系统变得复杂，管理多个回调变得困难，尤其是在跨组件或跨模块时。")]),a._v(" "),t("li",[a._v("订阅：订阅更适合于全局或模块化的状态管理系统，它允许对状态变化的追踪，订阅者能够在状态变化时做出相应的反应。这种方式在处理共享状态、跨组件通信时更加有效，尤其是在复杂的应用程序中(如 React、Vue 等)。")])]),a._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[a._v("支持异步流处理(Asynchronous Stream Handling)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：传统的回调函数通常处理单次的事件。虽然可以通过嵌套、链式调用等方式处理多个异步事件，但代码容易变得复杂(称为“回调地狱”)。")]),a._v(" "),t("li",[a._v("订阅：订阅机制非常适合异步数据流处理。像 RxJS 这样的库可以轻松处理多次异步事件，并对数据流进行转化、过滤、合并等操作。使用订阅机制，处理多个异步事件变得更加直观和可维护。")])]),a._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[a._v("响应式编程(Reactive Programming)")])]),a._v(" "),t("ul",[t("li",[a._v("回调函数：传统的回调并不具备响应式的特性，只是对某个具体事件作出反应。")]),a._v(" "),t("li",[a._v("订阅：订阅机制是响应式编程的基础，特别适合那些基于状态或数据流的应用。响应式系统通过订阅变化来自动调整和更新相关的 UI 或数据，减少了手动更新的需求。")])]),a._v(" "),t("RText",{attrs:{text:"结论"}}),a._v(" "),t("p",[a._v("订阅机制比传统的回调函数更适合用于复杂的应用场景，尤其是在状态管理和数据流控制方面。它不仅提高了代码的模块化和可维护性，还为异步流和多订阅者处理提供了强大的支持。")])],1)}),[],!1,null,null,null);t.default=l.exports}}]);